diff --git a/README.md b/README.md
index 58ae416..b20fd7d 100644
--- a/README.md
+++ b/README.md
@@ -59,6 +59,8 @@ go run ./cmd/auditpack run --in /path/to/input_dir --out /path/to/out_dir \
 
 `--label` is optional. Use it when `--in` is an absolute path and you want stable, portable metadata.
 
+If `--out` is inside `--in` (e.g. `--in . --out ./out`), auditpack will exclude the `--out` subtree from hashing to avoid "self-capturing" old packs.
+
 ### Verify a pack
 
 Verifies `manifest.sha256` (pack output integrity) and basic invariants on `manifest.json` (sorted paths, uniqueness, stable totals).
diff --git a/docs/HANDOFF.md b/docs/HANDOFF.md
index 9c1f457..657387f 100644
--- a/docs/HANDOFF.md
+++ b/docs/HANDOFF.md
@@ -71,6 +71,7 @@ go build -o bin/auditpack ./cmd/auditpack
 
 Notes:
 - `--label` is optional. Use it when `--in` is an absolute path and you want stable, portable metadata.
+- If `--out` is inside `--in` (e.g. `--in . --out ./out`), auditpack will exclude the `--out` subtree from hashing to avoid "self-capturing" old packs.
 
 ### Demo mode (creates a tiny input tree for you)
 
diff --git a/internal/auditpack/build.go b/internal/auditpack/build.go
index 04a1df3..a564308 100644
--- a/internal/auditpack/build.go
+++ b/internal/auditpack/build.go
@@ -49,6 +49,31 @@ func Build(inDir, outDir string, opts Options) error {
 		label = inDir
 	}
 
+	// If the output directory is inside the input tree (a common workflow:
+	// --in . --out ./out), exclude that subtree so we never "self-capture" prior
+	// packs that happen to live under the input directory.
+	//
+	// We determine containment using absolute paths (stable across ./ and ..).
+	excludeRel := ""
+	if outDir != "" {
+		inAbs, errIn := filepath.Abs(inDir)
+		outAbs, errOut := filepath.Abs(outDir)
+		if errIn == nil && errOut == nil {
+			relOut, err := filepath.Rel(inAbs, outAbs)
+			if err == nil {
+				relOut = filepath.ToSlash(relOut)
+				relOut = path.Clean(relOut)
+				if relOut == "." {
+					return fmt.Errorf("outDir must not equal inDir: %s", outDir)
+				}
+				// If outDir is under inDir, relOut will not start with ../
+				if relOut != ".." && !strings.HasPrefix(relOut, "../") {
+					excludeRel = relOut
+				}
+			}
+		}
+	}
+
 	entries := make([]manifest.FileEntry, 0, 64)
 	var totalBytes int64
 
@@ -56,6 +81,24 @@ func Build(inDir, outDir string, opts Options) error {
 		if walkErr != nil {
 			return walkErr
 		}
+
+		// Exclude outDir subtree when outDir is within inDir.
+		if excludeRel != "" {
+			rel, err := filepath.Rel(inDir, p)
+			if err != nil {
+				return err
+			}
+			rel = filepath.ToSlash(rel)
+			rel = path.Clean(rel)
+
+			if rel == excludeRel || strings.HasPrefix(rel, excludeRel+"/") {
+				if d.IsDir() {
+					return fs.SkipDir
+				}
+				return nil
+			}
+		}
+
 		if d.IsDir() {
 			return nil
 		}
diff --git a/tests/exclude_outdir_test.go b/tests/exclude_outdir_test.go
new file mode 100644
index 0000000..a36b014
--- /dev/null
+++ b/tests/exclude_outdir_test.go
@@ -0,0 +1,64 @@
+package tests
+
+import (
+	"encoding/json"
+	"os"
+	"path/filepath"
+	"testing"
+
+	"github.com/nicholaskarlson/proof-first-auditpack/internal/auditpack"
+	"github.com/nicholaskarlson/proof-first-auditpack/internal/manifest"
+)
+
+func mustWrite(t *testing.T, p string, data []byte) {
+	t.Helper()
+	if err := os.MkdirAll(filepath.Dir(p), 0o755); err != nil {
+		t.Fatalf("mkdir %s: %v", filepath.Dir(p), err)
+	}
+	if err := os.WriteFile(p, data, 0o644); err != nil {
+		t.Fatalf("write %s: %v", p, err)
+	}
+}
+
+func TestBuildExcludesOutDirWhenInsideInput(t *testing.T) {
+	t.Parallel()
+
+	root := t.TempDir()
+	inDir := filepath.Join(root, "in")
+	outDir := filepath.Join(inDir, "out")
+
+	// Real input file.
+	mustWrite(t, filepath.Join(inDir, "a.txt"), []byte("hello\n"))
+
+	// Stale pack junk under outDir (the footgun we want to eliminate).
+	mustWrite(t, filepath.Join(outDir, "old.txt"), []byte("stale"))
+	mustWrite(t, filepath.Join(outDir, "sub", "older.txt"), []byte("staler"))
+
+	opts := auditpack.DefaultOptions()
+	opts.Version = "dev"
+	opts.InputLabel = "test/input"
+
+	if err := auditpack.Build(inDir, outDir, opts); err != nil {
+		t.Fatalf("build: %v", err)
+	}
+
+	b, err := os.ReadFile(filepath.Join(outDir, "manifest.json"))
+	if err != nil {
+		t.Fatalf("read manifest.json: %v", err)
+	}
+
+	var m manifest.Manifest
+	if err := json.Unmarshal(b, &m); err != nil {
+		t.Fatalf("unmarshal manifest.json: %v", err)
+	}
+
+	if m.Summary.FileCount != 1 {
+		t.Fatalf("expected 1 file in manifest, got %d", m.Summary.FileCount)
+	}
+	if len(m.Files) != 1 {
+		t.Fatalf("expected 1 file entry, got %d", len(m.Files))
+	}
+	if m.Files[0].Path != "a.txt" {
+		t.Fatalf("expected only a.txt, got %q", m.Files[0].Path)
+	}
+}
